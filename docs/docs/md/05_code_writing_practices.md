---
next: ./06_db
prev: ./04_dependency_management
---

# Практики написания кода

## Основы

PHP &mdash; это обширный язык, который позволяет разработчикам всех уровней писать код не только быстро, но и эффективно. В любом случае, изучая язык, мы нередко забываем основы, которые мы изучали изначально (или бегло просмотрели), в пользу коротких путей и/или вредных привычек. Чтобы помочь в борьбе с этой общей проблемой, эта секция предназначена для напоминания разработчикам основ практик написания кода PHP.

## Дата и время

PHP содержит встроенный класс DateTime, предназначенный для чтения, записи, сравнения и вычисления даты или времени. Также в PHP много функций, связанных с датой и временем, помимо класса DateTime, но класс предоставляет хороший объектно-ориентированный интерфейс для решения большинства задач. Он способен даже обрабатывать временные зоны, но это уже не рассматривается в данном коротком введении.

Для начала работы с DateTime, сконвертируйте «сырую» строку даты и времени в объект с помощью фабричного метода `createFromFormat()` или выполните `new \DateTime`, чтобы получить текущую дату и время. Используйте метод `format()` для конвертирования DateTime обратно в строку для вывода.
```php
<?php
$raw = '22. 11. 1968';
$start = \DateTime::createFromFormat('d. m. Y', $raw);

echo 'Start date: ' . $start->format('m/d/Y') . "\n";
```

Вычисления с DateTime возможны с использованием класса DateInterval. У класса DateTime есть методы `add()` и `sub()`, которые принимают DateInterval, как аргумент. Не пишите код, который ожидает одинаковое число секунд каждый день, перевод часов и смена часовых поясов разрушат это предположение. Вместо этого используйте интервалы дат. Для расчета разницы между датами используйте метод `diff()`. Он вернет новый объект DateInterval, который очень легко отобразить. 
```php
<?php
// создает копию $start и добавляет 1 месяц и 6 дней
$end = clone $start;
$end->add(new \DateInterval('P1M6D'));

$diff = $end->diff($start);
echo 'Difference: ' . $diff->format('%m месяц, %d дней (total: %a дней)') . "\n";
// Разница : 1 месяц, 6 дней (всего : 37 дней)
```

С объектами DateTime, вы можете использовать стандартные методы сравнения:
```php
<?php
if ($start < $end) {
    echo "Начальная дата раньше конечной!\n";
}
```

И последний пример для демонстрации класса DatePeriod. Он используется для перебора повторяющихся событий. Класс может принимать два объекта DateTime, начало и конец, и интервал, для которого он вернет все события между ними.
```php
<?php
// выводит все четверги между началом и концом
$periodInterval = \DateInterval::createFromDateString('first thursday');
$periodIterator = new \DatePeriod($start, $periodInterval, $end, \DatePeriod::EXCLUDE_START_DATE);
foreach ($periodIterator as $date) {
    // вывести каждую дату в периоде
    echo $date->format('m/d/Y') . ' ';
}
```

* [Подробнее о DateTime][datetime]
* [Подробнее о форматировании даты][dateformat] (разрешенные опции строки формата даты)

[datetime]: http://www.php.net/manual/ru/book.datetime.php
[dateformat]: http://www.php.net/manual/ru/function.date.php

## Design Patterns

При построении приложения полезно использовать в коде шаблоны, а также придерживаться некоторых стандартов для всей структуры проекта. Использование шаблонов полезно, потому что оно упрощает управление кодом, а также позволяет другим разработчикам быстро понять, как всё взаимодействует друг с другом.

Если вы используете фреймворк, то большинство высокоуровневого кода и структура проекта будет основываться на архитектуре фреймворка, поэтому большинство решений относительно шаблона сделано за вас. Но всё же наиболее верным решением будет выбрать наиболее подходящие шаблоны и следовать им в коде, который вы пишете на базе фреймворка. С другой стороны, если вы не используете фреймворк для построения приложения, тогда вы должны найти шаблоны, которые наилучшим образом соответствуют типу и размеру приложения, которое вы создаете.

* Продолжить чтение [Шаблоны проектирования](/ru-php-the-right-way/pages/Шаблоны-проектирования.html)

## Исключения

Исключения &mdash; это неотъемлемая часть большинства популярных языков программирования, но зачастую PHP разработчики не уделяют им должного внимания. Языки, подобные Ruby, очень подробно обрабатывают исключения, поэтому, если что-то идёт не верно, например: не удался HTTP запрос, запрос к базе данных происходит неправильно или если запрошенное изображение не было найдено, Ruby (или используемые гемы) выбросит исключение на экран, помогающее понять где вы допустили ошибку.

PHP сам по себе довольно слаб в плане этого и вызов `file_get_contents()`, как правило, даст вам только `FALSE` и предупреждение. Многие устаревшие PHP-фреймворки, как CodeIgniter, просто вернут false, добавят сообщение в свой собственный журнал и, может быть, дадут вам использовать метод, как `$this->upload->get_error()`, чтобы посмотреть, что пошло не так. Проблема в том, что вы должны искать ошибку и проверять документацию, чтобы понять, какой ошибочный метод существует в этом классе, вместо того, чтобы сделать это всё более очевидным.

Еще одна проблема в том, что классы автоматически выдают ошибку на экран и закрывают процесс. Когда вы делаете это, вы не даете другому разработчику динамически обработать эту ошибку. Исключения должны быть выброшены, чтобы дать разработчику знать об ошибке и выбрать, как её обработать. Например:

```php
<?php
$email = new Fuel\Email;
$email->subject('My Subject');
$email->body('How the heck are you?');
$email->to('guy@example.com', 'Some Guy');

try
{
    $email->send();
}
catch(Fuel\Email\ValidationFailedException $e)
{
    // Валидация не удалась
}
catch(Fuel\Email\SendingFailedException $e)
{
    // Драйвер не может отправить сообщение
}
```

### Исключения SPL

Универсальный класс `Exception` предоставляет очень мало отладочного контекста для разработчика; как бы то ни было, для того чтобы исправить это, можно создать специализированный класс, который будет расширять возможности универсального класса `Exception`:

```php
<?php
class ValidationException extends Exception {}
```

Это означает, что вы можете добавить несколько блоков отлова и обрабатывать разные исключения по-разному. Это может привести к созданию <em>множества</em> изменённых Исключений, некоторые из которых можно было бы избежать, используя Исключения SPL, предоставляемые [расширением SPL][splext].

Например, если вы используете магический метод `__call()` и вами был вызван неизвестный метод, то вместо выбрасывания стандартного исключения, которое очень расплывчато, или вместо создания своего исключения, вы можете просто использовать `throw new BadFunctionCallException;`.

* [Подробнее об Исключениях][exceptions]
* [Подробнее о SPL Исключениях][splexe]
* [Вложенные исключения в PHP][nesting-exceptions-in-php]
* [Лучшие практики использования исключений в PHP 5.3][exception-best-practices53]

[exceptions]: http://php.net/manual/ru/language.exceptions.php
[splexe]: http://php.net/manual/ru/spl.exceptions.php
[splext]: /#standard_php_library
[exception-best-practices53]: http://ralphschindler.com/2010/09/15/exception-best-practices-in-php-5-3
[nesting-exceptions-in-php]: http://www.brandonsavage.net/exceptional-php-nesting-exceptions-in-php/
